<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Veritas - Game Session</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            color: #e0e0ff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        #game-session {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, rgba(20, 20, 40, 0.3) 0%, rgba(5, 5, 10, 0.9) 100%);
        }

        .listening-container {
            text-align: center;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .listening-container.active {
            opacity: 1;
        }

        .listening-pulse {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 167, 181, 0.3) 0%, transparent 70%);
            margin: 0 auto 30px;
            position: relative;
            animation: pulse 3s ease-in-out infinite;
        }

        .listening-pulse::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 167, 181, 0.5) 0%, transparent 70%);
            animation: pulse 3s ease-in-out infinite 0.5s;
        }

        .listening-pulse::after {
            content: 'üéôÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            filter: drop-shadow(0 0 10px rgba(0, 167, 181, 0.8));
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .listening-text {
            font-size: 18px;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: #00a7b5;
            text-shadow: 0 0 20px rgba(0, 167, 181, 0.5);
            margin-bottom: 10px;
        }

        .listening-subtext {
            font-size: 14px;
            color: #4a5568;
            font-style: italic;
        }

        .end-session-btn {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.8);
            border: 2px solid #00a7b5;
            color: #00a7b5;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .end-session-btn:hover {
            background: #00a7b5;
            color: white;
        }

        .status-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4a5568;
        }

        .status-dot.active {
            background: #00a7b5;
            box-shadow: 0 0 10px rgba(0, 167, 181, 0.8);
        }

        .debug-info {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #4a5568;
            font-size: 12px;
            text-align: center;
        }

        /* RULING OVERLAY - ENHANCED */
        #ruling-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.98);
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 40px;
            backdrop-filter: blur(20px);
            overflow-y: auto;
        }

        #ruling-overlay.active {
            display: flex;
        }

        .ruling-header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }

        .ruling-icon {
            font-size: 48px;
            margin-bottom: 15px;
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(0, 167, 181, 0.5)); }
            50% { transform: scale(1.05); filter: drop-shadow(0 0 40px rgba(0, 167, 181, 0.8)); }
        }

        .ruling-announcement {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #c9a86a;
            margin-bottom: 10px;
        }

        .ruling-title {
            font-size: 32px;
            font-weight: 300;
            color: #e0e0ff;
            text-shadow: 0 0 30px rgba(0, 167, 181, 0.3);
        }

        /* CARD DISPLAY */
        .card-display {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            max-width: 900px;
            width: 100%;
            margin-bottom: 30px;
        }

        .card-image-container {
            flex-shrink: 0;
            width: 250px;
            height: 350px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid rgba(0, 167, 181, 0.3);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .card-placeholder {
            color: #4a5568;
            font-size: 14px;
            text-align: center;
        }

        .ruling-content {
            flex: 1;
            text-align: left;
        }

        .card-name {
            font-size: 28px;
            color: #00a7b5;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .arbiter-dialogue {
            background: rgba(0, 167, 181, 0.1);
            border-left: 4px solid #00a7b5;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: #e0e0ff;
            line-height: 1.6;
        }

        .arbiter-dialogue::before {
            content: '"';
            font-size: 40px;
            color: #00a7b5;
            float: left;
            margin-right: 10px;
            line-height: 1;
        }

        .ruling-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 167, 181, 0.2);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .ruling-section h3 {
            color: #c9a86a;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .ruling-section p {
            color: #8892b0;
            line-height: 1.6;
        }

        .official-rulings {
            max-height: 200px;
            overflow-y: auto;
        }

        .ruling-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 3px solid #c9a86a;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 167, 181, 0.3);
            border-top-color: #00a7b5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .ruling-close {
            margin-top: 20px;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid #00a7b5;
            color: #00a7b5;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 25px;
        }

        .ruling-close:hover {
            background: #00a7b5;
            color: white;
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>

    <button class="end-session-btn" onclick="endSession()">End Session & Analyze</button>

    <div id="game-session">
        <div class="listening-container active" id="listening-container">
            <div class="listening-pulse"></div>
            <div class="listening-text">Listening</div>
            <div class="listening-subtext">The Arbiter hears all</div>
        </div>

        <div class="debug-info" id="debug-info">Session time: 0:00 | Disputes: 0</div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot active" id="mic-status"></div>
                <span>Microphone Active</span>
            </div>
        </div>
    </div>

    <!-- ENHANCED RULING OVERLAY -->
    <div id="ruling-overlay">
        <div class="ruling-header">
            <div class="ruling-icon">‚öñÔ∏è</div>
            <div class="ruling-announcement">A disturbance ripples through the aether</div>
            <div class="ruling-title">The Law Has Been Determined</div>
        </div>

        <div class="card-display" id="card-display">
            <div class="card-image-container">
                <div class="card-placeholder" id="card-image">Searching for card...</div>
            </div>
            
            <div class="ruling-content" id="ruling-content">
                <div class="loading-spinner"></div>
                <p style="text-align: center; color: #4a5568;">The Arbiter consults the archives...</p>
            </div>
        </div>

        <button class="ruling-close" onclick="closeRuling()">The Stack Resolves. Continue.</button>
    </div>

    <script>
        // ============================================
        // SESSION DATA
        // ============================================
        window.sessionData = {
            startTime: new Date().toISOString(),
            endTime: null,
            players: ['Player 1', 'Player 2', 'Player 3', 'Player 4'],
            events: [],
            disputes: [],
            winner: 'Unknown'
        };

        let disputeCount = 0;
        let recognition;
        let currentCardData = null;

        // ============================================
        // TIMER & DEBUG INFO
        // ============================================
        function updateDebugInfo() {
            const elapsed = Math.floor((new Date() - new Date(window.sessionData.startTime)) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            document.getElementById('debug-info').textContent = 
                `Session time: ${mins}:${secs.toString().padStart(2, '0')} | Disputes: ${disputeCount}`;
        }
        
        setInterval(updateDebugInfo, 1000);
        updateDebugInfo();

        // ============================================
        // END SESSION
        // ============================================
        function endSession() {
            console.log('=== ENDING SESSION ===');
            
            window.sessionData.endTime = new Date().toISOString();
            window.sessionData.gameLength = Math.floor((new Date() - new Date(window.sessionData.startTime)) / 1000);
            
            const dataString = JSON.stringify(window.sessionData);
            localStorage.setItem('veritas_session', dataString);
            
            if (recognition) {
                recognition.stop();
            }
            
            window.location.href = 'analysis.html';
        }

        // ============================================
        // CARD NAME EXTRACTION
        // ============================================
        function extractCardName(text) {
            // Common MTG card name patterns
            const patterns = [
                /target\s+my\s+(\w+(?:\s+\w+)*)/i,
                /target\s+(\w+(?:\s+\w+)*)/i,
                /cast\s+(\w+(?:\s+\w+)*)/i,
                /play\s+(\w+(?:\s+\w+)*)/i,
                /(\w+(?:\s+\w+)*)\s+trigger/i,
                /(\w+(?:\s+\w+)*)\s+ability/i,
                /destroy\s+(\w+(?:\s+\w+)*)/i,
                /exile\s+(\w+(?:\s+\w+)*)/i,
                /return\s+(\w+(?:\s+\w+)*)/i,
                /(\w+(?:\s+\w+)*)\s+enters/i,
                /when\s+(\w+(?:\s+\w+)*)/i,
                /if\s+(\w+(?:\s+\w+)*)/i
            ];

            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }

            // If no pattern matches, return the most capitalized word sequence
            const words = text.split(/\s+/);
            let bestGuess = '';
            let currentSequence = '';
            
            for (const word of words) {
                if (word[0] && word[0] === word[0].toUpperCase()) {
                    currentSequence += (currentSequence ? ' ' : '') + word;
                } else {
                    if (currentSequence.length > bestGuess.length) {
                        bestGuess = currentSequence;
                    }
                    currentSequence = '';
                }
            }
            
            return bestGuess || text;
        }

        // ============================================
        // SCRYFALL API SEARCH
        // ============================================
        async function searchCard(cardName) {
            try {
                const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
                if (!response.ok) throw new Error('Card not found');
                return await response.json();
            } catch (error) {
                console.error('Scryfall search failed:', error);
                return null;
            }
        }

        async function getCardRulings(cardId) {
            try {
                const response = await fetch(`https://api.scryfall.com/cards/${cardId}/rulings`);
                if (!response.ok) throw new Error('No rulings found');
                const data = await response.json();
                return data.data || [];
            } catch (error) {
                console.error('Rulings fetch failed:', error);
                return [];
            }
        }

        // ============================================
        // ARBITER DIALOGUE GENERATOR
        // ============================================
        function generateArbiterDialogue(cardName, oracleText, context) {
            const openers = [
                "The threads of fate have brought this matter before me.",
                "I have gazed into the aether and the Law is clear.",
                "Your dispute echoes across the planes. Hear now my judgment.",
                "The scales tip toward clarity. Listen well.",
                "I have walked the blind eternities to bring you this truth."
            ];

            const explanations = [
                `The card ${cardName} operates within the comprehensive rules as follows.`,
                `The mechanics of ${cardName} are bound by these principles.`,
                `This Arbiter has consulted the ancient texts regarding ${cardName}.`,
                `The interaction you question is governed by these laws.`
            ];

            const closers = [
                "The stack resolves. Continue your game.",
                "May this knowledge guide your path to victory.",
                "The Law has spoken. Play on.",
                "With clarity comes power. Use it wisely."
            ];

            const opener = openers[Math.floor(Math.random() * openers.length)];
            const explanation = explanations[Math.floor(Math.random() * explanations.length)];
            const closer = closers[Math.floor(Math.random() * closers.length)];

            return {
                opener: opener,
                explanation: explanation,
                closer: closer
            };
        }

        // ============================================
        // DISPLAY RULING
        // ============================================
        async function showRuling(text) {
            const cardName = extractCardName(text);
            console.log('Detected card name:', cardName);

            // Show overlay immediately with loading state
            document.getElementById('ruling-overlay').classList.add('active');
            document.getElementById('card-image').innerHTML = 'Searching for card...';
            document.getElementById('ruling-content').innerHTML = `
                <div class="loading-spinner"></div>
                <p style="text-align: center; color: #4a5568;">The Arbiter consults the archives...</p>
            `;

            // Search for card
            const cardData = await searchCard(cardName);
            currentCardData = cardData;

            let rulings = [];
            if (cardData) {
                rulings = await getCardRulings(cardData.id);
            }

            // Generate dialogue
            const dialogue = generateArbiterDialogue(
                cardData ? cardData.name : cardName,
                cardData ? cardData.oracle_text : '',
                text
            );

            // Build display
            let html = '';

            // Arbiter dialogue
            html += `<div class="arbiter-dialogue">${dialogue.opener} ${dialogue.explanation}</div>`;

            // Card info
            if (cardData) {
                html += `<div class="card-name">${cardData.name}</div>`;
                
                // Oracle text
                html += `
                    <div class="ruling-section">
                        <h3>Oracle Text</h3>
                        <p>${cardData.oracle_text || 'No oracle text available.'}</p>
                    </div>
                `;

                // Official rulings
                if (rulings.length > 0) {
                    html += `
                        <div class="ruling-section">
                            <h3>Official Rulings</h3>
                            <div class="official-rulings">
                    `;
                    
                    rulings.slice(0, 3).forEach(ruling => {
                        html += `<div class="ruling-item">${ruling.comment}</div>`;
                    });
                    
                    html += `</div></div>`;
                }

                // Update card image
                const imageUrl = cardData.image_uris ? cardData.image_uris.normal : 
                                (cardData.card_faces && cardData.card_faces[0].image_uris ? 
                                 cardData.card_faces[0].image_uris.normal : null);
                
                if (imageUrl) {
                    document.getElementById('card-image').innerHTML = 
                        `<img src="${imageUrl}" class="card-image" alt="${cardData.name}">`;
                } else {
                    document.getElementById('card-image').innerHTML = 
                        `<div class="card-placeholder">No image available<br>for ${cardData.name}</div>`;
                }
            } else {
                html += `
                    <div class="ruling-section">
                        <h3>General Ruling</h3>
                        <p>The Arbiter could not locate the specific card "${cardName}" in the archives. 
                        However, based on your question "${text}", remember that targets must be legal 
                        when chosen and the spell or ability must have a valid target to be put on the stack.</p>
                    </div>
                `;
                document.getElementById('card-image').innerHTML = 
                    `<div class="card-placeholder">Card not found:<br>${cardName}</div>`;
            }

            // Add closer
            html += `<div class="arbiter-dialogue" style="border-left-color: #c9a86a; background: rgba(201, 168, 106, 0.1);">${dialogue.closer}</div>`;

            document.getElementById('ruling-content').innerHTML = html;

            // Speak the ruling
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(dialogue.opener);
                utterance.rate = 0.8;
                utterance.pitch = 0.9;
                speechSynthesis.speak(utterance);
            }
        }

        function closeRuling() {
            document.getElementById('ruling-overlay').classList.remove('active');
            currentCardData = null;
        }

        // ============================================
        // DISPUTE DETECTION
        // ============================================
        class DisputeDetector {
            constructor() {
                this.confidence = 0;
                this.threshold = 3;
                this.lastTriggerTime = 0;
                this.cooldown = 5000;

                this.triggers = {
                    uncertainty: ['wait', 'hold on', 'does that', 'can you', 'not sure', 'confused'],
                    challenge: ["you can't", 'you cannot', 'illegal', 'wrong', 'not legal', 'invalid'],
                    mtg_terms: ['target', 'stack', 'priority', 'trigger', 'combat', 'phase', 'cast', 'destroy']
                };

                this.weights = { uncertainty: 2, challenge: 3, mtg_terms: 1 };
            }

            analyze(text) {
                const lowerText = text.toLowerCase();
                let score = 0;

                for (const [category, words] of Object.entries(this.triggers)) {
                    for (const word of words) {
                        if (lowerText.includes(word)) {
                            score += this.weights[category];
                        }
                    }
                }

                const now = Date.now();
                if (score >= this.threshold && (now - this.lastTriggerTime) > this.cooldown) {
                    this.lastTriggerTime = now;
                    return { detected: true, text: text };
                }
                return { detected: false };
            }
        }

        const detector = new DisputeDetector();

        // ============================================
        // SPEECH RECOGNITION
        // ============================================
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                document.getElementById('listening-container').classList.add('active');
                console.log('Listening started');
            };

            recognition.onend = () => {
                document.getElementById('listening-container').classList.remove('active');
                setTimeout(() => recognition.start(), 100);
            };

            recognition.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        console.log('Heard:', transcript);
                        const result = detector.analyze(transcript);
                        if (result.detected) {
                            handleDispute(result.text);
                        }
                    }
                }
            };

            recognition.onerror = (e) => {
                console.log('Speech error:', e.error);
                setTimeout(() => recognition.start(), 1000);
            };

            recognition.start();
        } else {
            alert('Speech recognition not supported. Please use Chrome.');
        }

        function handleDispute(text) {
            disputeCount++;
            
            window.sessionData.disputes.push({
                time: new Date().toISOString(),
                text: text
            });
            
            console.log('Dispute recorded:', text);
            showRuling(text);
            updateDebugInfo();
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.opacity = Math.random() * 0.5 + 0.1;
                this.color = Math.random() > 0.5 ? '#00a7b5' : '#c9a86a';
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.reset();
                }
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push(new Particle());
            }
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateParticles);
        }

        window.addEventListener('resize', () => { resizeCanvas(); initParticles(); });
        resizeCanvas();
        initParticles();
        animateParticles();
    </script>
</body>
</html>
